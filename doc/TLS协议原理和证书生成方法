# 1. 前言
网络技术不断发展，网络中存在的攻击行为也层出不穷，恶意攻击者作为中间人窃取网络信息，篡改网络信息，或者冒充合法服务器的行为，也成为我们设计网络协议，搭建网络通信服务器时，必须重点考虑的问题。
MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的轻量级协议，该协议构建于TCP/IP协议之上，MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。
该协议默认情况下，以密文的形式进行消息的发布。因此，在本章节中，将通过TLS协议对MQTT发布的信息进行加密，确保消息的安全传输，保证数据的保密性和数据保证性。
最终效果是，虚拟机发生状态变化时，发布者会以事件的形式，通知到订阅者，发布的事件信息通过TLS协议进行加密。

# 2. TLS协议简介
本文将会以HTTPS为例，来介绍TLS协议原理。

## 2.1 HTTP为什么不安全？
在介绍TLS协议之前，先介绍一下HTTP协议存在的缺陷，以便于后续大家更好的了解TLS协议的设计思路。

a. 窃听风险
HTTP协议数据包在网络中以明文的形式传递，攻击者通过抓包软件捕获网络中的数据包，即可读到HTTP中的信息。

b. 篡改
攻击者（中间人）可以窃取server的信息，对报文内容进行篡改，然后发送给client。
 
c. 冒充
client以为在跟合法的网站在通信，实际上可能再跟一个钓鱼网站在通信。
 
HTTP协议之所以会存在上述问题，主要是因为HTTP协议没有对应用数据进行加密，没有完整性校验和身份验证功能。

## 2.2 网络安全的四个原则

机密性：网络中传递的数据，经过加密算法进行加密；就算中间人窃听，他也无法获取其中的内容；

完整性：指数据传输过程中，没有被篡改，就算被篡改，也能检测出来。

身份认证：能够确认对方的身份的合法性。

不可否认：对自己操作过的网络行为，不能否认。

# 2.3 HTTPS通信原理
以下例子为HTTP+TLSv1.2的握手和通信过程。

a. 浏览器向服务器的443端口发起请求，发送报文为TLS的client hello报文，报文中携带了浏览器支持的对称加密算法和哈希算法。 

b. 服务器收到client hello报文，选择浏览器和本身都支持的加密算法和哈希算法，回应server hello报文。同时，服务器会将自己的证书信息发送给浏览器，这里的数字证书可以是向某个可靠机构（CA）申请的，也可以是自制的（自签名证书），使用wireshark抓包软件，可以捕捉到certification、exchangeKey和hellodone报文。其中certification携带证书信息，hellodone表示第一阶段的握手完成。

注意，服务器证书中有服务器的签名信息，签名信息怎么来的呢？服务器使用事前协商好的哈希算法对证书进行哈希运行，得到哈希值A，然后使用密钥信息对哈希值A进行加密，得到密文A，这个密文A就是签名。

c. 浏览器收到服务器的证书，于是进入到认证环节。 首先浏览器会从内置的证书列表中索引，找到服务器证书的颁发机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。浏览器上就会显示证书不安全，由用户来选择是否信任。

d. 如果查到了对应的机构，是可信的，则取出该机构颁发的公钥。用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、服务器的公钥、证书的有效期等。

e. 浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站（server）公钥了。

f. 浏览器验证证书签名的合法性，使用服务器的公钥对签名进行解密，得到哈希值A。然后，浏览器使用事先协商好的哈希算法对证书进行哈希运行得到哈希B。对比哈希A和哈希B是否一致。如果一致，说明证书没有被篡改，是合法的。

g. 浏览器生成一个随机数R，并使用服务器的公钥对R进行加密，得到密文RC。浏览器将密文RC传送给服务器。服务器收到密文RC后，用自己的私钥解密得到R。

h. 后续交互应用层数据时，服务器会议R为密钥，使用事先协商好的对称加密算法，加密网页内容并传输给浏览器。浏览器以R为密钥，使用之前约定好的对称秘钥，解密网页，获取网页内容。

# 3. MQTT协议的服务端和客户端如何获取证书？
## 3.1 服务端的配置
服务端，即broker，代理服务器。在broker上的配置非常重要。

在broker上生成好，CA证书，CA密钥，broker证书，broker密钥，client证书和client密钥。后续client，即发布者和订阅者上，只需要直接拷贝broker上生成好的CA证书，CA密钥，client证书和client密钥即可。

### 3.1.1生成CA证书和CA密钥
创建目录certs，在certs目录下创建目录ca，在ca目录下，使用如下命令：

openssl req -new -x509 -days 365 -extensions v3_ca -keyout ca.key -out ca.crt
 
这个地方的Common Name对于后续影响不大，设置为openssl，之类的都可以。

### 3.1.2生成broker密钥(即，broker.key)
在certs目录下创建目录broker，在broker目录下，使用如下命令：

openssl genrsa -out broker.key 2048

### 3.1.3 使用broker密钥，创建一个签名请求文件(即，broker.csr)
在broker目录下，使用如下命令：

openssl req -out broker.csr -key broker.key –new

注意：这里的Common Name非常重要！！必须填域名！！

broker上面填主机名就可以了，例如：61服务器的主机名为libing-dev-61，那么这里就填入libing-dev-61。

### 3.1.4将证书签名请求(csr)文件传递给我们的验证机构
在broker目录下，使用如下命令：

openssl x509 -req -in broker.csr -CA ../ca/ca.crt -CAkey ../ca/ca.key -CAcreateserial -out broker.crt -days 100
 
### 3.1.5生成client密钥(即，client.key)
在certs目录下创建目录client，在client目录下，使用如下命令：

openssl genrsa -out client.key 2048

### 3.1.6根据client密钥，创建client签名请求文件(即，client.csr)
在client目录下，使用如下命令：

openssl req -out client.csr -key client.key –new
 
这里的Common Name非常重要！！必须填域名！！

broker上面填主机名就可以了，例如：61服务器的主机名为server，那么这里就填入server。

### 3.1.7将证书签名请求(csr)文件传递给我们的验证机构
在client目录下，使用如下命令：

openssl x509 -req -in client.csr -CA ../ca/ca.crt -CAkey ../ca/ca.key -CAcreateserial -out client.crt -days 100

到了这里单机模式下的MQTT+TLS就完成了，可以先测试一下单机模式能不能通。

修改配置文件：

vim /etc/mosquitto/mosquitto.conf
 
重启mosquitt服务：
systemctl restart mosquitto.service

打开第一个窗口：
mosquitto_sub -p 18883 --cafile ../ca/ca.crt --cert client.crt --key client.key -h libing-dev-61 -t ab  -d

打开第二个窗口：
mosquitto_pub -p 18883 --cafile ../ca/ca.crt --cert client.crt --key client.key -h libing-dev-61 -m hello -t ab –d

其中，-d表示调试，debug，会看到明显的发布和订阅信息

## 3.2 发布者上的配置
a. 使用scp将CA证书，CA密钥，client证书和client密钥拷贝到发布者服务器上。
b. 配置mosquitto.conf配置文件，
c. 重启mosquitto服务。
命令如下：
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/ca/ca.crt ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/ca/ca.key ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/client/client.crt ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/client/client.key ./
vim /etc/mosquitto/mosquitto.conf
systemctl restart mosquitto.service
d. 绑定ip地址和域名
注意：这一步非常重要！！因为MQTT+TLS访问的时候，是通过域名解析为IP地址，然后再根据IP地址去访问的！！
命令如下：
vim /etc/hosts
broker的IP地址 broker的主机名
在/etc/hosts文件中，加入一条ip地址到域名的映射，即broker的IP地址 broker的主机名。

## 3.3订阅者上的配置
订阅者的配置和发布者的配置是一样的。

a. 使用scp将CA证书，CA密钥，client证书和client密钥拷贝到发布者服务器上;
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/ca/ca.crt ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/ca/ca.key ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/client/client.crt ./
scp root@<broker的IP地址>:/root/cLan/mosquitto/certs/client/client.key ./

b. 配置mosquitto.conf配置文件;
vim /etc/mosquitto/mosquitto.conf

c. 重启mosquitto服务;
systemctl restart mosquitto.service

d. 绑定ip地址和域名
注意：这一步非常重要！！因为MQTT+TLS访问的时候，是通过域名解析为IP地址，然后再根据IP地址去访问的！！
命令如下：
vim /etc/hosts

<broker的IP地址> <broker的主机名>

在/etc/hosts文件中，加入一条ip地址到域名的映射，即broker的IP地址 broker的主机名。

## 3.4 实验验证
通过命令的方式进行验证。

发布者：
mosquitto_pub -p 18883 --cafile ../ca/ca.crt --cert client.crt --key client.key -h <broker的主机名> -m hello -t ab –d

订阅者：
mosquitto_sub -p 18883 --cafile ../ca/ca.crt --cert client.crt --key client.key -h <broker的主机名> -t ab -d
 

## 3.4 实验效果
在broker上使用tcpdump进行抓包，可以获取发布者发送的数据，通过wireshark打开，可以看到信息都通过TLS协议进行加密。
 
 



